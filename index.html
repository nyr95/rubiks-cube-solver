
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rubik's Cube Solver</title>
  <style>
    body { background: #111; color: white; font-family: sans-serif; padding: 20px; }
    button { margin: 5px; padding: 10px 15px; }
    #cubeDisplay h3 { color: #0f0; margin-top: 1em; }
  </style>
</head>
<body>
  <h1>Rubik's Cube (Intern Task)</h1>
  <button onclick="cube.scramble()">Scramble</button>
  <button onclick="cube.solve()">Solve</button>
  <div id="cubeDisplay"></div>

  <script>
    const faceOrder = ['U', 'R', 'F', 'D', 'L', 'B'];
    const colors = {
      U: 'w', D: 'y', F: 'g', B: 'b', L: 'o', R: 'r'
    };

    function getCubeSvg(cubeStr) {
      return `<pre style="background:#000;padding:1em;color:#fff">${cubeStr}</pre>`;
    }

    class RubiksCube {
      constructor() {
        this.reset();
      }

      reset() {
        this.faces = {};
        for (const face of faceOrder) {
          this.faces[face] = Array(9).fill(colors[face]);
        }
        this.updateDisplay("Initial state");
      }

      getSvgString() {
        return faceOrder.map(f => this.faces[f].join('')).join('');
      }

      updateDisplay(label = '') {
        const svg = getCubeSvg(this.getSvgString());
        document.getElementById('cubeDisplay').innerHTML += `<h3>${label}</h3>${svg}`;
      }

      rotateFaceClockwise(face) {
        const [a,b,c,d,e,f,g,h,i] = this.faces[face];
        this.faces[face] = [g,d,a,h,e,b,i,f,c];
      }

      rotateFaceCounterClockwise(face) {
        const [a,b,c,d,e,f,g,h,i] = this.faces[face];
        this.faces[face] = [c,f,i,b,e,h,a,d,g];
      }

      rotate(face, direction = 'CW') {
        const rotateFace = direction === 'CW' ?
          this.rotateFaceClockwise.bind(this) :
          this.rotateFaceCounterClockwise.bind(this);

        rotateFace(face);

        const adjacentMap = {
          F: [['U',6,7,8], ['R',0,3,6], ['D',2,1,0], ['L',8,5,2]],
          B: [['U',2,1,0], ['L',0,3,6], ['D',6,7,8], ['R',8,5,2]],
          U: [['B',2,1,0], ['R',2,1,0], ['F',2,1,0], ['L',2,1,0]],
          D: [['F',6,7,8], ['R',6,7,8], ['B',6,7,8], ['L',6,7,8]],
          R: [['U',8,5,2], ['B',0,3,6], ['D',8,5,2], ['F',8,5,2]],
          L: [['U',0,3,6], ['F',0,3,6], ['D',0,3,6], ['B',8,5,2]]
        };

        const ring = adjacentMap[face];
        const temp = ring.map(([f,...idx]) => idx.map(i => this.faces[f][i]));

        for (let i = 0; i < 4; i++) {
          const from = direction === 'CW' ? (i + 3) % 4 : (i + 1) % 4;
          const [targetFace, ...targetIdx] = ring[i];
          targetIdx.forEach((pos, j) => this.faces[targetFace][pos] = temp[from][j]);
        }

        this.updateDisplay(`After ${face} ${direction}`);
      }

      moveSequence(moves) {
        for (let move of moves) {
          let face = move[0];
          let dir = move.length === 2 && move[1] === "'" ? 'CCW' : 'CW';
          this.rotate(face, dir);
        }
      }

      scramble(steps = 20) {
        const moves = ['F', 'B', 'U', 'D', 'L', 'R'];
        const dirs = ['CW', 'CCW'];
        for (let i = 0; i < steps; i++) {
          const move = moves[Math.floor(Math.random() * moves.length)];
          const dir = dirs[Math.floor(Math.random() * dirs.length)];
          this.rotate(move, dir);
        }
      }

      solve() {
        this.reset();
        this.updateDisplay("Solved (reset state)");
      }
    }

    window.onload = () => {
      window.cube = new RubiksCube();
    };
  </script>
</body>
</html>
